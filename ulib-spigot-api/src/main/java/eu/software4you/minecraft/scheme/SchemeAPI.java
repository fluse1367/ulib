package eu.software4you.minecraft.scheme;

import eu.software4you.math.Coordinate3D;
import eu.software4you.ulib.ULib;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.*;

public class SchemeAPI {

    public static Scheme loadScheme(InputStream in) {
        Scanner sc = new Scanner(in);
        List<DynamicBlock> blocks = new ArrayList<>();
        while (sc.hasNextLine()) {
            String line = sc.nextLine();

            if (line.contains("#"))
                line = line.substring(0, line.indexOf("#"));
            line = line.replace(" ", "");

            if (!line.equals("")) {
                String[] a = line.split(";");
                blocks.add(
                        new DynamicBlock(
                                new Coordinate3D(
                                        Double.valueOf(a[0]),
                                        Double.valueOf(a[1]),
                                        Double.valueOf(a[2])
                                ),
                                new BlockData(
                                        Material.getMaterial(a[3]),
                                        Short.valueOf(a[4])
                                )
                        )
                );
            }
        }
        sc.close();
        return new Scheme(blocks);
    }

    public static Scheme loadScheme(Location loc1, Location loc2, Location center, Material... ignored) {
        return loadScheme(loc1, loc2, center, new ArrayList<>(Arrays.asList(ignored)));
    }

    public static Scheme loadScheme(Location loc1, Location loc2, Location center, List<Material> ignored) {
        if (!(loc1.getWorld() == loc2.getWorld() && center.getWorld() == loc1.getWorld()))
            throw new IllegalArgumentException("The locations must be in the same world!");

        World w = loc1.getWorld();
        List<DynamicBlock> blocks = new ArrayList<>();

        int cx = center.getBlockX(), cy = center.getBlockY(), cz = center.getBlockZ();
        int x1 = loc1.getBlockX(), y1 = loc1.getBlockY(), z1 = loc1.getBlockZ();
        int x2 = loc2.getBlockX(), y2 = loc2.getBlockY(), z2 = loc2.getBlockZ();

        int xx = x1 < x2 ? 1 : -1;
        int yy = y1 < y2 ? 1 : -1;
        int zz = z1 < z2 ? 1 : -1;

        for (int i = x1; i != x2 + xx; i += xx) {
            //System.out.println("X: "+(cx - i));
            for (int j = y1; j != y2 + yy; j += yy) {
                //System.out.println("Y: "+(cy - j));
                for (int k = z1; k != z2 + zz; k += zz) {
                    //System.out.println("Z: "+(cz - k));
                    int x = cx - i, y = cy - j, z = cz - k;
                    Block b = new Location(w, i, j, k).getBlock();
                    if (!ignored.contains(b.getType()))
                        blocks.add(new DynamicBlock(new Coordinate3D(x, y, z), new BlockData(b.getType(), b.getData())));
                }
            }
        }

        return new Scheme(blocks);
    }

    public static void saveScheme(Scheme scheme, OutputStream out) throws IOException {
        out.write(("# Generated by Software4You.eu's uLib v" + ULib.getInstance().getVersion() + ". You are not allowed to edit or remove this line! Software4you \u00a9"/* \u00a9 = Â© */ + new SimpleDateFormat("yyyy").format(new Date()) + "\n").getBytes());
        for (DynamicBlock block : scheme.getBlocks()) {
            Coordinate3D c = block.getCoordinate3D();
            String line = c.getX() + ";" + c.getY() + ";" + c.getZ() + ";" + block.getBlockData().getMaterial().name() + ";" + block.getBlockData().getDurability() + "\n";
            out.write(line.getBytes());
        }
        out.flush();
        out.close();
    }
}