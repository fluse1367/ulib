import com.github.jengelman.gradle.plugins.shadow.tasks.ConfigureShadowRelocation
import org.apache.tools.ant.filters.ReplaceTokens

defaultTasks 'clean', 'build', 'jar'
apply plugin: 'java-library'

// shadowing - start
buildscript {
    repositories {
        maven { url 'https://plugins.gradle.org/m2/' }
    }
    dependencies {
        classpath 'gradle.plugin.com.github.jengelman.gradle.plugins:shadow:7.0.0'
    }
}
// shadowing - end

// docs build - start
task docsWebpage {
    subprojects {
        if (project.name.endsWith('-api')) {
            dependsOn "${project.name}:javadoc"
        }
    }

    doLast {
        delete 'public'

        mkdir 'public'
        copy {
            from 'docs'
            into 'public'
        }

        subprojects {
            if (!project.name.endsWith('-api')) return

            def name = project.name
            name = name.substring(name.indexOf("-") + 1, name.lastIndexOf("-"))

            copy {
                from "${buildDir}/docs/javadoc"
                into "${rootDir}/public/$name"
            }

        }
    }
}

clean {
    delete "${rootDir}/public"
}
// docs build - end

allprojects {

    def major = 2, minor = 0, patch = 0

    group 'eu.software4you.ulib'
    version "$major.$minor.$patch${project.hasProperty('release') ? '' : '-SNAPSHOT'}"

    repositories {
        mavenCentral()

        maven {
            name 'PaperMC'
            url 'https://papermc.io/repo/repository/maven-public/'
        }
        if (project.name.contains('velocity')) {
            maven {
                name = 'velocitypowered-repo'
                url = 'https://repo.velocitypowered.com/releases/'
            }
        }
    }

    ext {
        gitCommitHash = { ->
            try {
                def stdout = new ByteArrayOutputStream()
                exec {
                    commandLine 'git', 'rev-parse', '--short', 'HEAD'
                    standardOutput = stdout
                }
                return stdout.toString().trim()
            } catch (Exception ignored) {
                return "unknown"
            }
        }

        def release = project.hasProperty('release')

        deployRepoUrl = "https://gitlab.com/api/v4/projects/${release ? /*ulib*/ '19415500' : /*ulib-snapshots*/ '26647460'}/packages/maven"
        deployRepoCredentialMethod = "${release ? 'Job' : 'Deploy'}-Token"
        deployRepoCredentialValue = System.getenv("CI_${release ? /*releases*/ 'JOB' : /*snapshots*/ 'SNAPSHOT_REPOSITORY_DEPLOY'}_TOKEN")

        coordsPaper = 'com.destroystokyo.paper:paper-api:1.16.4-R0.1-SNAPSHOT'
        coordsWaterfall = 'io.github.waterfallmc:waterfall-api:1.16-R0.4-SNAPSHOT'
        coordsVelocity = 'com.velocitypowered:velocity-api:1.1.3-SNAPSHOT'
        coordsXSeries = 'com.github.cryptomorin:XSeries:7.9.1.1'

        coordsJetbrainsAnnotations = 'org.jetbrains:annotations:20.1.0'
        coordsLombok = 'org.projectlombok:lombok:1.18.6'

        coordsJavassist = 'org.javassist:javassist:3.27.0-GA'

        def props = new Properties()
        props.putAll([
                version         : version.toString(),
                'maven.mysql'   : 'mysql:mysql-connector-java:8.0.23',
                'maven.sqlite'  : 'org.xerial:sqlite-jdbc:3.25.2',
                'maven.xseries' : coordsXSeries,
                'maven.mail-api': 'javax.mail:javax.mail-api:1.6.2',
                'maven.smtp'    : 'com.sun.mail:smtp:1.6.3',
        ])

        replacementTokens = props
    }

}

subprojects {
    apply plugin: 'java-library'
    apply plugin: 'maven-publish'

    compileJava {
        options.encoding = 'UTF-8'
    }

    compileTestJava {
        options.encoding = 'UTF-8'
    }

    java {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    jar {
        manifest {
            attributes 'Implementation-Title': project.name
            attributes 'Implementation-Version': "${archiveVersion.get()}-${gitCommitHash()}"
            attributes 'Specification-Version': archiveVersion.get()
            attributes 'Implementation-Vendor': 'Software4You.eu'
            attributes 'Built-By': System.getProperty("user.name")
            attributes 'Build-Jdk': System.getProperty("java.version")
            attributes 'Created-By': 'Gradle ' + gradle.gradleVersion
        }
    }

    configurations {
        shade
    }

    // default dependencies
    dependencies {
        implementation coordsJetbrainsAnnotations
        implementation coordsLombok

        // annotation
        annotationProcessor coordsLombok
    }

    ext {
        /**
         * Adds a list of dependencies as compileOnly and shade dependency.
         */
        compileShade = { depList ->
            dependencies {
                for (String dependency : depList) {
                    // exclusion
                    if (dependency.startsWith('!(') && dependency.contains("):") && dependency.split(':').length == 4) {
                        int i;
                        String excl = dependency.substring(2, i = dependency.indexOf("):"))
                        dependency = dependency.substring(i + 2);

                        implementation(dependency) {
                            exclude group: excl
                        }
                        shade(dependency) {
                            exclude group: excl
                        }
                        continue
                    }

                    implementation dependency
                    shade dependency
                }
            }
        }
    }

    // replace tokens - start
    task processSources(type: Sync) {
        from sourceSets.main.java.srcDirs
        //inputs.property 'version', version.toString()
        filter ReplaceTokens, beginToken: '{{', endToken: '}}', tokens: replacementTokens
        into "$buildDir/src"
    }
    compileJava.source = processSources.outputs

    processResources {
        filter ReplaceTokens, beginToken: '{{', endToken: '}}', tokens: replacementTokens
    }
    // replace tokens - end

    // shadowing
    if (project.name == 'ulib-core'
            || project.name == 'ulib-spigot'
            || project.name == 'ulib-bungeecord'
            || project.name == 'ulib-velocity') {
        apply plugin: 'com.github.johnrengelman.shadow' // shadowing

        ext {
            shadowJarIncludeFrom = { projects ->
                for (String sub : projects) {
                    def proj = ':ulib-' + sub
                    def buildDir = project(proj).buildDir

                    shadowJar {
                        dependsOn "$proj:build"
                        from("$buildDir/classes/java/main") { include '**' }
                        from("$buildDir/resources/main") { include '**' }
                    }
                }
            }
        }

        // https://imperceptiblethoughts.com/shadow/configuration/relocation/#automatically-relocating-dependencies
        task relocateShadowJar(type: ConfigureShadowRelocation) {
            target = tasks.shadowJar
            prefix = "ulib.ported"
        }

        // https://imperceptiblethoughts.com/shadow/configuration/dependencies/#configuring-shadowed-dependencies
        shadowJar {
            def ex = project(':ulib-libex')
            dependsOn ':ulib-libex:jar'
            dependsOn tasks.relocateShadowJar

            from("${ex.buildDir}/libs/") {
                include "libex"
            }

            dependencies {
                exclude(dependency(coordsLombok))
            }
        }
    }
    // shadowing end

    // publishing
    if (project.name.endsWith("-api")) {
        javadoc {
            title "${project.name.substring(0, project.name.lastIndexOf('-api'))} ${jar.archiveVersion.get()} API"
            if (project.name != 'ulib-core-api') {
                def projects = ['minecraft-api', 'core-api']
                for (String sub : projects) {
                    def proj = project(':ulib-' + sub)
                    source(proj.projectDir.getPath() + "/src/main/java")
                    //classpath = files(classpath.files, proj.configurations.compileClasspath.collect())
                }
            }
            failOnError false
        }

        java {
            withSourcesJar()
            withJavadocJar()
        }

        artifacts {
            archives sourcesJar
            archives javadocJar
        }

        publishing {
            publications {
                library(MavenPublication) {
                    from components.java
                    // exclude runtime dependencies from pom
                    pom.withXml {
                        asNode().dependencies.'*'.findAll() {
                            it.scope.text() == 'runtime'
                        }.each() {
                            it.parent().remove(it)
                        }
                    }
                }
            }
            repositories {
                maven {
                    url deployRepoUrl
                    credentials(HttpHeaderCredentials) {
                        name = deployRepoCredentialMethod
                        value = deployRepoCredentialValue
                    }
                    authentication {
                        header(HttpHeaderAuthentication)
                    }
                }
            }
        }
    }
    // publishing end
}